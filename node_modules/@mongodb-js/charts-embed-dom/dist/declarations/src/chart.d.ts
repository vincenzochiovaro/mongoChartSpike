import { ChattyHostBuilder } from '@looker/chatty';
import BaseEmbedItem from './base-embed-item';
import { EmbedChartOptions, RenderingSpec } from './types';
declare class ChartEventSender extends BaseEmbedItem {
    protected name: string;
    protected ERRORS: {
        SEND: string;
        IFRAME: string;
    };
    protected COLOUR: {
        LIGHT: string;
        DARK: string;
    };
    protected options: EmbedChartOptions;
    /** @ignore */
    constructor(options: Partial<EmbedChartOptions>);
    protected getEmbedUrl(): string;
}
declare const Chart_base: {
    new (...args: any[]): {
        setHighlight(value: import("./types").PlainObject): Promise<void>;
        getHighlight(): Promise<import("./types").PlainObject>;
        getData(): Promise<object>;
        _send(msgName: string, ...payload: unknown[]): Promise<[unknown]>;
    };
} & {
    new (...args: any[]): {
        setFilter(value: import("./types").PlainObject): Promise<void>;
        getFilter(): Promise<import("./types").PlainObject>;
        _send(msgName: string, ...payload: unknown[]): Promise<[unknown]>;
    };
} & {
    new (...args: any[]): {
        refresh(): Promise<void>;
        _send(msgName: string, ...payload: unknown[]): Promise<[unknown]>;
    };
} & {
    new (...args: any[]): {
        _eventHandlers: Record<import("./types").EmbedChartEvent, Record<string, {
            handle: import("./types").EventHandler;
            options: import("./types").EventHandlerOptions;
        }>>;
        _handleEvent(event: import("./types").EmbedChartEvent, payload: import("./types").EventHandlerPayload, handlerIds: string[]): void;
        addEventListener(event: import("./types").EmbedChartEvent, eventHandler: import("./types").EventHandler, options?: import("./types").EventHandlerOptions | undefined): Promise<unknown>;
        removeEventListener(event: import("./types").EmbedChartEvent, eventHandler: import("./types").EventHandler, options?: import("./types").EventHandlerOptions | undefined): Promise<unknown>;
        _send(msgName: string, ...payload: unknown[]): Promise<[unknown]>;
    };
} & typeof ChartEventSender;
/**
 * # Chart
 *
 * Allows you to interact and embed charts into your application.
 *
 * ```js
 * const sdk = new EmbedSDK({ ... });
 * const chart = sdk.createChart({ ... });
 *
 * // renders a chart
 * chart.render(document.getElementById('embed-chart'));
 *
 * // dynamically set a filter
 * chart.setFilter({ age: { $gt: 50 } });
 * ```
 */
declare class Chart extends Chart_base {
    private renderingSpec;
    /**
     * Sends the `ready` event to Charts to render the embedded chart in the component
     * @param container where the chart will render
     */
    render(container: HTMLElement): Promise<void>;
    /**
     * @returns the number of seconds a chart will wait before refreshing
     * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.
     */
    getRefreshInterval(): Promise<number>;
    /**
     * Set the number of seconds a chart will wait before refreshing.
     *
     * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.
     * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.
     */
    setRefreshInterval(value: number): Promise<void>;
    protected _configureHost(hostBuilder: ChattyHostBuilder): ChattyHostBuilder;
    /**
     * Sets a set of customizations on the rendered chart
     * @param value customization settings and values
     * @returns a promise that resolves once the rendering spec is saved and the component rerendered
     */
    setRenderingSpecOverride(value: RenderingSpec): Promise<void>;
    /**
     * Get the channel data from the current chart
     * @returns a promise that resolves to the channel data on the current chart
     */
    getChannels(): Promise<Record<string, {
        field: string;
        channelType: string;
    }>>;
    /**
     * Get the customizable axes data from the current chart
     * @returns a promise that resolves to the axis data on the current chart
     */
    getCustomizableAxes(): Promise<Record<string, {
        fields: string[];
    }> | Record<string, never>>;
    /**
     * Gets the customizations applied to a chart after initial render
     * @returns the customized rendering spec or undefined.
     */
    getRenderingSpecOverride(): RenderingSpec | undefined;
}
export default Chart;
export type { Chart };
