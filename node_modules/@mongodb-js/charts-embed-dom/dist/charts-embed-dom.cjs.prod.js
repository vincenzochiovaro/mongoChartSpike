"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var chatty = require("@looker/chatty"), bson = require("bson"), _isEqual = require("lodash/isEqual"), _isEmpty = require("lodash/isEmpty");

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    default: e
  };
}

var _isEqual__default = _interopDefault(_isEqual), _isEmpty__default = _interopDefault(_isEmpty);

function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

function createElement(name) {
  let props = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, children = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
  const element = document.createElement(name);
  for (const [name, value] of Object.entries(props)) "style" === name ? Object.assign(element.style, props.style) : element.setAttribute(name, value);
  for (const child of Array.isArray(children) ? children : [ children ]) element.append(child);
  return element;
}

let THEME, SCALING, ENCODING;

!function(THEME) {
  THEME.DARK = "dark", THEME.LIGHT = "light";
}(THEME || (THEME = {})), function(SCALING) {
  SCALING.FIXED = "fixed", SCALING.SCALE = "scale";
}(SCALING || (SCALING = {})), function(ENCODING) {
  ENCODING.BASE64 = "base64", ENCODING.BINARY = "binary";
}(ENCODING || (ENCODING = {}));

const SDK_PROTOCOL_CHART = "3", SDK_PROTOCOL_DASHBOARD = "3", isPlainObject = value => "object" == typeof value && null !== value && !Array.isArray(value), getSharedEmbedOptions = options => {
  const {background: background, baseUrl: baseUrl, autoRefresh: autoRefresh, maxDataAge: maxDataAge, width: width, height: height, theme: theme, showAttribution: showAttribution, getUserToken: getUserToken, filter: filter} = options;
  if ("string" != typeof baseUrl || 0 === baseUrl.length) throw new Error("Base URL must be a valid URL");
  if (void 0 !== background && "string" != typeof background) throw new Error("background must be a string if specified");
  if (void 0 !== autoRefresh && "boolean" != typeof autoRefresh) throw new Error("autoRefresh must be a boolean if specified");
  if (void 0 !== maxDataAge && "number" != typeof maxDataAge) throw new Error("maxDataAge must be a number if specified");
  if (void 0 !== width && ![ "number", "string" ].includes(typeof width)) throw new Error("Width must be a string or number if specified");
  if (void 0 !== height && ![ "number", "string" ].includes(typeof height)) throw new Error("Height must be a string or number if specified");
  if (void 0 !== theme && "string" != typeof theme) throw new Error("Theme must be a string if specified");
  if (void 0 !== showAttribution && "boolean" != typeof showAttribution) throw new Error("Attribution must be a boolean value if specified");
  if (void 0 !== getUserToken && "function" != typeof getUserToken) throw new Error("getUserToken must be a function");
  if (void 0 !== filter && !isPlainObject(filter)) throw new Error("Filter must be an object if specified");
  return {
    background: background,
    baseUrl: baseUrl,
    autoRefresh: autoRefresh,
    maxDataAge: maxDataAge,
    width: width,
    height: height,
    theme: theme,
    showAttribution: showAttribution,
    getUserToken: getUserToken,
    filter: filter
  };
}, getPathname = (url, pathname) => [ url.pathname, "/" === url.pathname.slice(-1) ? "" : "/", pathname ].join(""), getChartUrl = options => {
  try {
    const url = new URL(options.baseUrl);
    return url.pathname = getPathname(url, "embed/charts"), url.search = `id=${options.chartId}&sdk=3`, 
    !1 === options.autoRefresh ? url.search += "&autorefresh=false" : void 0 === options.autoRefresh && (url.search += options.refreshInterval ? `&autorefresh=${options.refreshInterval}` : ""), 
    void 0 !== options.maxDataAge && (url.search += `&maxDataAge=${options.maxDataAge}`), 
    options.filter && (url.search += `&filter=${encodeURIComponent(bson.EJSON.stringify(options.filter, {
      relaxed: !1
    }))}`), options.theme && (url.search += `&theme=${options.theme}`), !1 === options.showAttribution && (url.search += "&attribution=false"), 
    url.toString();
  } catch (e) {
    throw new Error("Base URL must be a valid URL");
  }
}, getDashboardUrl = options => {
  try {
    const url = new URL(options.baseUrl);
    return url.pathname = getPathname(url, "embed/dashboards"), url.search = `id=${options.dashboardId}&sdk=3`, 
    !1 === options.autoRefresh && (url.search += "&autoRefresh=false"), void 0 !== options.maxDataAge && (url.search += `&maxDataAge=${options.maxDataAge}`), 
    !0 === options.showTitleAndDesc && (url.search += "&showTitleAndDesc=true"), options.widthMode && (url.search += `&scalingWidth=${options.widthMode}`), 
    options.heightMode && (url.search += `&scalingHeight=${options.heightMode}`), options.theme && (url.search += `&theme=${options.theme}`), 
    options.chartsBackground && (url.search += `&chartsBackground=${options.chartsBackground}`), 
    options.background && (url.search += `&background=${options.background}`), !1 === options.showAttribution && (url.search += "&attribution=false"), 
    options.filter && (url.search += `&filter=${encodeURIComponent(bson.EJSON.stringify(options.filter, {
      relaxed: !1
    }))}`), url.toString();
  } catch (e) {
    throw new Error("Base URL must be a valid URL");
  }
}, parseCSSMeasurement = value => "string" == typeof value ? value : "number" == typeof value ? `${value}px` : null, getBackground = (background, theme, lightBackground, darkBackground) => "string" == typeof background && background.length > 0 ? background : "dark" === theme ? darkBackground : lightBackground, MAX_QUERY_EXECUTION_MS = 6e5;

class BaseEmbedItem {
  constructor() {
    _defineProperty(this, "iframe", void 0), _defineProperty(this, "connection", void 0), 
    _defineProperty(this, "name", void 0), _defineProperty(this, "ERRORS", void 0), 
    _defineProperty(this, "COLOUR", void 0), _defineProperty(this, "options", void 0);
  }
  async render(container) {
    if (this.iframe) throw new Error(this.ERRORS.IFRAME);
    const embedRoot = this._configureEmbedRoot(createElement("div", {
      style: {
        position: "relative",
        overflow: "hidden",
        minHeight: Boolean(this.options.height) ? 0 : "15px",
        width: parseCSSMeasurement(this.options.width) || "100%",
        height: parseCSSMeasurement(this.options.height) || "100%"
      }
    })), host = this._configureHost(chatty.Chatty.createHost(this.getEmbedUrl()).withDefaultTimeout(6e5).withSandboxAttribute("allow-scripts").withSandboxAttribute("allow-same-origin").withSandboxAttribute("allow-popups").withSandboxAttribute("allow-popups-to-escape-sandbox").appendTo(embedRoot)).build();
    for (host.iframe.setAttribute("aria-label", this.name), Object.assign(host.iframe.style, {
      position: "absolute",
      top: 0,
      left: 0,
      border: 0,
      width: "100%",
      height: "100%"
    }); container.firstChild; ) container.removeChild(container.firstChild);
    container.appendChild(embedRoot), this.connection = await host.connect(), this.iframe = host.iframe, 
    this._setBackground(this.options.background, this.options.theme), await this._retrieveAndSetToken();
  }
  async isAutoRefresh() {
    const [result] = await this._send("get", "autoRefresh");
    return "number" == typeof result || "boolean" == typeof result ? Boolean(result) : Promise.reject("unexpected response received from iframe");
  }
  async setAutoRefresh(value) {
    if ("boolean" != typeof value) return Promise.reject("autoRefresh property value should be a boolean");
    await this._send("set", "autoRefresh", value);
  }
  async getMaxDataAge() {
    const [result] = await this._send("get", "maxDataAge");
    return "number" == typeof result ? result : Promise.reject("unexpected response received from iframe");
  }
  async setMaxDataAge(value) {
    if ("number" != typeof value) return Promise.reject("maxDataAge property value should be a number");
    await this._send("set", "maxDataAge", value);
  }
  async setTheme(value) {
    if ("string" != typeof value) return Promise.reject("theme property value should be a string");
    const newTheme = Object.values(THEME).includes(value) ? value : THEME.LIGHT;
    await this._send("set", "theme", newTheme), this._setBackground(this.options.background, newTheme);
  }
  async getTheme() {
    const [result] = await this._send("get", "theme");
    return "string" == typeof result ? result : Promise.reject("unexpected response received from iframe");
  }
  _configureHost(hostBuilder) {
    return hostBuilder.on("refreshToken", (() => this._retrieveAndSetToken()));
  }
  _configureEmbedRoot(embedRoot) {
    return embedRoot;
  }
  _setBackground(background, theme) {
    this.iframe.style.backgroundColor = getBackground(background, theme, this.COLOUR.LIGHT, this.COLOUR.DARK);
  }
  async _retrieveAndSetToken() {
    if (this.options.getUserToken) {
      const token = await this.options.getUserToken();
      await this._send("set", "token", token);
    }
  }
  _send(eventName) {
    if (this.connection) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) payload[_key - 1] = arguments[_key];
      return this.connection.sendAndReceive(eventName, ...payload);
    }
    return Promise.reject(this.ERRORS.SEND);
  }
  async getImage(options) {
    const {encoding: encoding} = options || {};
    if (encoding !== ENCODING.BASE64 && encoding !== ENCODING.BINARY) return Promise.reject('Encoding must be either "base64" or "binary"');
    const [result] = await this._send("get", "image", {
      background: this.options.background,
      encoding: encoding
    });
    return "string" == typeof result || result instanceof Blob ? result : Promise.reject("unexpected response received from iframe");
  }
}

let eventHandlerIndex = Date.now();

function EventSource(Sender) {
  return class extends Sender {
    constructor() {
      super(...arguments), _defineProperty(this, "_eventHandlers", {
        click: {}
      });
    }
    _handleEvent(event, payload, handlerIds) {
      const handlers = this._eventHandlers[event];
      for (const id of handlerIds) try {
        var _handlers$id;
        null === (_handlers$id = handlers[id]) || void 0 === _handlers$id || _handlers$id.handle(payload);
      } catch (error) {
        console.warn(`Error calling handler for event [${event}]: ${error}`);
      }
    }
    addEventListener(event, eventHandler, options) {
      var _h$options$includes;
      const handlers = this._eventHandlers[event];
      if (!handlers) throw new Error(`Not supported event: ${event}`);
      const h = {
        handle: eventHandler,
        options: {
          includes: null == options ? void 0 : options.includes
        }
      };
      if (null !== (_h$options$includes = h.options.includes) && void 0 !== _h$options$includes && _h$options$includes.every((f => _isEmpty__default.default(f))) && console.warn("Empty includes filters out all events. Event handler will never be called. Is this intended?"), 
      !Object.keys(handlers).some((id => _isEqual__default.default(handlers[id], h)))) {
        const handlerId = (++eventHandlerIndex).toString(36);
        return handlers[handlerId] = h, this._send("eventHandler", event, {
          handlerId: handlerId,
          options: h.options
        });
      }
      return Promise.resolve();
    }
    removeEventListener(event, eventHandler, options) {
      const handlers = this._eventHandlers[event];
      if (!handlers) throw new Error(`Not supported event: ${event}`);
      const h = {
        handle: eventHandler,
        options: {
          includes: null == options ? void 0 : options.includes
        }
      }, handlerId = Object.keys(handlers).find((id => _isEqual__default.default(handlers[id], h)));
      return handlerId ? (delete handlers[handlerId], this._send("eventHandler", event, {
        handlerId: handlerId
      })) : Promise.resolve();
    }
  };
}

function Refreshable(Sender) {
  return class extends Sender {
    async refresh() {
      await this._send("refresh");
    }
  };
}

function CommonChart(Sender) {
  return class extends Sender {
    async setHighlight(value) {
      if (!isPlainObject(value)) return Promise.reject("highlight property value should be an object");
      await this._send("set", "highlight", bson.EJSON.stringify(value, {
        relaxed: !1
      }));
    }
    async getHighlight() {
      const [result] = await this._send("get", "highlight");
      return isPlainObject(result) ? result : Promise.reject("unexpected response received from iframe");
    }
    async getData() {
      const [result] = await this._send("get", "data");
      return "object" == typeof result && null !== result ? result : Promise.reject("unexpected response received from iframe");
    }
  };
}

function Filterable(Sender) {
  return class extends Sender {
    async setFilter(value) {
      if (!isPlainObject(value)) return Promise.reject("filter property value should be an object");
      await this._send("set", "filter", bson.EJSON.stringify(value, {
        relaxed: !1
      }));
    }
    async getFilter() {
      const [result] = await this._send("get", "filter");
      return isPlainObject(result) ? result : Promise.reject("unexpected response received from iframe");
    }
  };
}

const getChartOptions = options => {
  if ("object" != typeof options || null === options) throw new Error("Options argument must be an object");
  const sharedEmbedOptions = getSharedEmbedOptions(options), {chartId: chartId, refreshInterval: refreshInterval, renderingSpec: renderingSpec} = options;
  if ("string" != typeof chartId || 0 === chartId.length) throw new Error("chartId must be specified");
  if (void 0 !== refreshInterval && "number" != typeof refreshInterval) throw new Error("refreshInterval interval must be a number if specified");
  if (void 0 !== renderingSpec && !isPlainObject(renderingSpec)) throw new Error("renderingSpec must be an object if specified");
  if (void 0 !== renderingSpec && !renderingSpec.version) throw new Error("renderingSpec must contain a version key");
  return {
    ...sharedEmbedOptions,
    chartId: chartId,
    refreshInterval: refreshInterval,
    renderingSpec: renderingSpec
  };
};

class ChartEventSender extends BaseEmbedItem {
  constructor(options) {
    super(), _defineProperty(this, "name", "Embedded Chart"), _defineProperty(this, "ERRORS", {
      SEND: "Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.",
      IFRAME: "A chart can only be rendered into a container once"
    }), _defineProperty(this, "COLOUR", {
      LIGHT: "#FFFFFF",
      DARK: "#21313C"
    }), _defineProperty(this, "options", void 0), this.options = getChartOptions(options);
  }
  getEmbedUrl() {
    return getChartUrl(this.options);
  }
}

class Chart extends(CommonChart(Filterable(Refreshable(EventSource(ChartEventSender))))){
  constructor() {
    super(...arguments), _defineProperty(this, "renderingSpec", void 0);
  }
  async render(container) {
    await super.render(container);
    const renderingSpec = this.options.renderingSpec, initialState = renderingSpec ? {
      renderingSpec: renderingSpec
    } : {};
    await this._send("ready", initialState), initialState.renderingSpec && (this.renderingSpec = initialState.renderingSpec);
  }
  async getRefreshInterval() {
    const [result] = await this._send("get", "autorefresh");
    return console.warn("The 'getRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes."), 
    "number" == typeof result ? result : Promise.reject("unexpected response received from iframe");
  }
  async setRefreshInterval(value) {
    if ("number" != typeof value) return Promise.reject("refreshInterval property value should be a number");
    console.warn("The 'setRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes."), 
    await this._send("set", "autorefresh", value);
  }
  _configureHost(hostBuilder) {
    return super._configureHost(hostBuilder).on("event", this._handleEvent.bind(this));
  }
  async setRenderingSpecOverride(value) {
    return isPlainObject(value) ? value.version ? (await this._send("set", "renderingSpec", value), 
    void (this.renderingSpec = value)) : Promise.reject('renderingSpec should contain a "version" key') : Promise.reject("renderingSpec property value should be an object");
  }
  async getChannels() {
    const [result] = await this._send("get", "channels");
    return result && "object" == typeof result ? result : Promise.reject("Unexpected response from iframe");
  }
  async getCustomizableAxes() {
    const [result] = await this._send("get", "axes");
    return result && "object" == typeof result ? result : Promise.reject("Unexpected response from iframe");
  }
  getRenderingSpecOverride() {
    return this.renderingSpec;
  }
}

class DashboardChartEventSender {
  constructor(chartId, dashboard) {
    this.chartId = chartId, this.dashboard = dashboard;
  }
  _send(msgName) {
    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) payload[_key - 1] = arguments[_key];
    return this.dashboard._send(msgName, ...payload, this.chartId);
  }
}

class DashboardChart extends(CommonChart(Filterable(Refreshable(EventSource(DashboardChartEventSender))))){}

const getDashboardOptions = options => {
  if ("object" != typeof options || null === options) throw new Error("Options argument must be an object");
  const sharedEmbedOptions = getSharedEmbedOptions(options), {dashboardId: dashboardId, chartsBackground: chartsBackground, widthMode: widthMode, heightMode: heightMode, showTitleAndDesc: showTitleAndDesc, charts: charts} = options;
  if ("string" != typeof dashboardId || 0 === dashboardId.length) throw new Error("dashboardId must be specified");
  if (void 0 !== chartsBackground && "string" != typeof chartsBackground) throw new Error("chartsBackground must be a string if specified");
  if (void 0 !== widthMode && "string" != typeof widthMode) throw new Error("widthMode must be a string if specified");
  if (void 0 !== widthMode && widthMode !== SCALING.FIXED && widthMode !== SCALING.SCALE) throw new Error(`widthMode must be "${SCALING.FIXED}" or "${SCALING.SCALE}"`);
  if (void 0 !== heightMode && "string" != typeof heightMode) throw new Error("heightMode must be a string if specified");
  if (void 0 !== heightMode && heightMode !== SCALING.FIXED && heightMode !== SCALING.SCALE) throw new Error(`heightMode must be "${SCALING.FIXED}" or "${SCALING.SCALE}"`);
  if (void 0 !== showTitleAndDesc && "boolean" != typeof showTitleAndDesc) throw new Error("showTitleAndDesc must be a boolean value if specified");
  if (void 0 !== charts && !Array.isArray(charts)) throw new Error("charts embedding option must be an array if specified");
  if (void 0 !== charts) {
    const uniqueIds = {};
    if (charts.forEach((ch => uniqueIds[ch.chartId] = uniqueIds.chartId)), Object.keys(uniqueIds).length !== charts.length) throw new Error("charts embedding option must contain unique chartIds");
  }
  return {
    ...sharedEmbedOptions,
    dashboardId: dashboardId,
    chartsBackground: chartsBackground,
    widthMode: widthMode,
    heightMode: heightMode,
    showTitleAndDesc: showTitleAndDesc,
    charts: charts
  };
};

class DashboardEventSender extends BaseEmbedItem {
  constructor(options) {
    super(), _defineProperty(this, "name", "Embedded Dashboard"), _defineProperty(this, "ERRORS", {
      SEND: "Dashboard has not been rendered. Ensure that you wait for the promise returned by `dashboard.render()` before trying to manipulate a dashboard.",
      IFRAME: "A dashboard can only be rendered into a container once"
    }), _defineProperty(this, "COLOUR", {
      LIGHT: "#F1F5F4",
      DARK: "#12212C"
    }), _defineProperty(this, "options", void 0), this.options = getDashboardOptions(options);
  }
  getEmbedUrl() {
    return getDashboardUrl(this.options);
  }
}

class Dashboard extends(Filterable(Refreshable(DashboardEventSender))){
  constructor() {
    super(...arguments), _defineProperty(this, "charts", {});
  }
  async render(container) {
    await super.render(container), await this._send("ready", this.options.charts);
  }
  async getChartsBackground() {
    const [result] = await this._send("get", "chartsBackground");
    return "string" == typeof result ? result : Promise.reject("unexpected response received from iframe");
  }
  async setChartsBackground(value) {
    if ("string" != typeof value) return Promise.reject("chartsBackground property value should be a string");
    await this._send("set", "chartsBackground", value);
  }
  async isShowAttribution() {
    const [result] = await this._send("get", "attribution");
    return "boolean" == typeof result ? Boolean(result) : Promise.reject("unexpected response received from iframe");
  }
  async setShowAttribution(value) {
    if ("boolean" != typeof value) return Promise.reject("showAttribution property value should be a boolean");
    await this._send("set", "attribution", value);
  }
  async getWidthMode() {
    const [result] = await this._send("get", "scalingWidth");
    return result === SCALING.FIXED || result === SCALING.SCALE ? result : Promise.reject("unexpected response received from iframe");
  }
  async setWidthMode(value) {
    if (![ "fixed", "scale" ].includes(value)) return Promise.reject('widthMode property value should be a string value of "fixed" or "scale"');
    await this._send("set", "scalingWidth", value);
  }
  async getHeightMode() {
    const [result] = await this._send("get", "scalingHeight");
    return "fixed" === result || "scale" === result ? result : Promise.reject("unexpected response received from iframe");
  }
  async setHeightMode(value) {
    if (![ "fixed", "scale" ].includes(value)) return Promise.reject('heightMode property value should be a string value of "fixed" or "scale"');
    await this._send("set", "scalingHeight", value);
  }
  async getChart(id) {
    if (!this.charts[id]) {
      const [chartIds] = await this._send("get", "charts", [ id ]);
      if (!Array.isArray(chartIds)) return Promise.reject("unexpected response received from iframe");
      if (1 !== chartIds.length) return Promise.reject("Invalid chart id: " + id);
      this.charts[id] = new DashboardChart(id, this);
    }
    return this.charts[id];
  }
  async getAllCharts() {
    const [chartIds] = await this._send("get", "charts");
    if (!Array.isArray(chartIds)) return Promise.reject("unexpected response received from iframe");
    const charts = [];
    return chartIds.forEach((id => {
      this.charts[id] || (this.charts[id] = new DashboardChart(id, this)), charts.push(this.charts[id]);
    })), charts;
  }
  _configureHost(hostBuilder) {
    return super._configureHost(hostBuilder).on("event", ((event, payload, handlerIds) => {
      const chartId = payload.chartId;
      this.charts[chartId]._handleEvent(event, payload, handlerIds);
    }));
  }
}

const isJWTExpired = jwt => {
  try {
    const [header, payload, signature] = jwt.split("."), {exp: exp} = JSON.parse(atob(payload));
    return Date.now() / 1e3 >= exp - 300;
  } catch (e) {
    throw new Error("Not a vaid JWT token. Is the StitchClient/RealmClient configured correctly?");
  }
};

async function getRealmUserToken(appClient) {
  let token;
  if ("auth" in appClient) {
    const stitchClient = appClient;
    if (!stitchClient.auth.authInfo) throw new Error("Unfamiliar Stitch client version");
    if (!stitchClient.auth.isLoggedIn) throw new Error("Could not find a logged-in StitchUser. Is the StitchClient configured correctly?");
    if (!stitchClient.auth.authInfo.accessToken) throw new Error("Could not find a valid JWT. Is the StitchClient configured correctly?");
    if (isJWTExpired(stitchClient.auth.authInfo.accessToken)) if (stitchClient.auth.refreshCustomData) await stitchClient.auth.refreshCustomData(); else {
      if (!stitchClient.auth.refreshAccessToken) throw new Error("Could not refresh token. Unfamiliar Stitch client version");
      await stitchClient.auth.refreshAccessToken();
    }
    token = stitchClient.auth.authInfo.accessToken;
  } else {
    if (!("authenticator" in appClient)) throw new Error("Unfamiliar Stitch or Realm client version");
    {
      const realmClient = appClient;
      if (!realmClient.currentUser) throw new Error("Unfamiliar Realm client version");
      if (!realmClient.currentUser.isLoggedIn) throw new Error("Could not find a logged-in RealmUser. Is the RealmClient configured correctly?");
      if (!realmClient.currentUser.accessToken) throw new Error("Could not find a valid JWT. Is the RealmClient configured correctly?");
      if (isJWTExpired(realmClient.currentUser.accessToken)) {
        if (!realmClient.currentUser.refreshCustomData) throw new Error("Could not refresh token. Unfamiliar Realm client version");
        await realmClient.currentUser.refreshCustomData();
      }
      token = realmClient.currentUser.accessToken;
    }
  }
  return token;
}

class EmbedSDK {
  constructor(options) {
    _defineProperty(this, "defaultOptions", void 0), this.defaultOptions = options;
  }
  createChart(options) {
    return new Chart({
      ...this.defaultOptions,
      ...options
    });
  }
  createDashboard(options) {
    return new Dashboard({
      ...this.defaultOptions,
      ...options
    });
  }
}

exports.default = EmbedSDK, exports.getRealmUserToken = getRealmUserToken;
